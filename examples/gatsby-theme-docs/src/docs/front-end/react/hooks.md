---
title: Хуки
description: это функции JavaScript, которые налагают два дополнительных правила
---

это функции JavaScript, которые налагают два дополнительных правила:

- Хуки следует вызывать только **на верхнем уровне**. Не вызывайте хуки внутри циклов, условий или вложенных функций.
- Хуки следует вызывать только **из функциональных компонентов React**. Не вызывайте хуки из обычных JavaScript-функций. Есть только одно исключение, откуда можно вызывать хуки — это ваши пользовательские хуки.

# useState

setState - асинхронный, благодаря чему React может оптимизировать процесс изменения состояния и объединить несколько вызовов setState в один, чтобы отразить все изменения в одной перерисовке вместо нескольких.

# **useEffect и useLayoutEffect**

## **useEffect**

то хук, принимающий функцию, которая будет выполнена после каждой перерисовки компонента. 

```tsx
useEffect(() => {
  console.log('side effect')
}, []]
```

Однако, вторым параметром в `useEffect` передается массив зависимостей (переменные состояния) - при его наличии функция, переданная в `useEffect`, будет выполняться не при каждой перерисовке, а только в случае изменения элемента из массива зависимостей. `useEffect` вызывается асинхронно после перерисовки компонента.

## **useLayoutEffect**

**useLayoutEffect - это аналог useEffect, отличающийся тем, что выполняется синхронно до перерисовки компонента, что бывает крайне полезным при взаимодействии в функции-коллбеке с DOM.**

# **useCallback и useMemo**

Рассмотрите возможность использования **useCallback/useMemo** в следующих ситуациях:

- обработка больших объемов данных;
- работа с интерактивными графиками и диаграммами;
- реализация анимации;
- включение компонента в ленивую загрузку.

> Если **useCallback** и **useMemo** используются правильно, они необходимы, чтобы предотвратить повторные рендеры и сделать код более эффективным.
> 

## **useCallback**

кэширует экземпляр функции между визуализациями.

## **useMemo**

кэширует значение между визуализациями.

# **useContext**

`useContext`— это React Hook, который позволяет вам читать и подписываться на [контекст](https://react.dev/learn/passing-data-deeply-with-context) вашего компонента.

```tsx
const value = useContext(SomeContext)
```

Использование **context object** – отличная альтернатива **prop drilling**. Он позволяет получить доступ к глобальным данным, не передавая их в качестве props.

- **context object** содержит два элемента: провайдер и потребитель;
- provider должен обернуть дерево компонентов;
- **useContext()** позволяет получить доступ к глобальным данным из любых дочерних компонентов в дереве компонентов под оболочкой поставщика.
- чтобы избежать повторных рендеров, разделите свой контекст – используйте ThemeContext и AppContext.

# **useReducer**

Reducer – это событие, которое будет выполнено, чтобы получить только одно значение. Возвращаемое значение может быть числом, строкой, массивом или даже объектом, если это оно единственное. Кроме того, reducer возвращают новое значение, а не мутируют начальное.

Метод **reduce** полезен для получения одного значения после применения некоторой логики к группе значений.

- **редьюсеры** возвращают новое значение вместо того, чтобы мутировать начальное;
- **useReducer** используется с управлением состоянием;
- **useReducer** следует использовать при работе со сложной логикой состояний, несколькими подзначениями или когда состояние зависит от подзначений состояний.

# **useRef**

Этот хук сохраняет свое состояние между визуализациями компонентов. Магия заключается в его возможности мутировать, не вызывая повторного обновления вашего компонента, поскольку значение **useRef** существует вне цикла визуализации.

### **Для чего его использовать?**

- refs полезны для доступа к узлам DOM или элементам React (*то, что визуализируется*) и для хранения значений между визуализациями;
- **useRef()** не следует использовать для замены состояния, потому что она нереактивная и не вызовет повторную визуализацию;
- refs должны обновляться внутри эффектов и обработчиков событий, чтобы избежать странного поведения.