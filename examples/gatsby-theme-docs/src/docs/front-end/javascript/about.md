---
title: Теория Javascript
description: Мультипарадигменный язык программирования
---

## **ECMAScript**

это спецификация, стандарт скриптовых языков программирования, он является основой JS, поэтому любые изменения ECMAScript отражаются на JS.

## **Мультипарадигменный язык программирования**

Поддерживает объектно-ориентированный, императивный и функциональный стили. Является реализацией стандарта ECMAScript.

## Форма

В своей основной форме JavaScript является **синхронным**, **блокирующим**, **однопоточным языком**, в котором одновременно может выполняться только одна операция. Но веб-браузеры определяют функции и API, которые позволяют нам регистрировать функции, которые не должны выполняться синхронно, а должны вызываться асинхронно, когда происходит какое-либо событие (время, взаимодействие пользователя с мышью или получение данных по сети, например). Это означает, что вы можете позволить своему коду делать несколько вещей одновременно, не останавливая и не блокируя основной поток.

## **Область видимости**

это место, где мы имеем доступ к переменным и функциям, находящимся в ней. JS имеем три типа областей видимости: глобальная, функциональная и блочная (ES6).

## **Контекст выполнения**

это **среда**, в которой выполняется код. Фазы — **компиляция** и **выполнение**.

### Компиляция

В этой фазе функциональные выражения и переменные, объявленные с помощью ключевого слова `var`, со значением `undefined` поднимаются в самый верх глобальной (или функциональной) области видимости - как бы перемещаются в начало нашего кода. Это объясняет, почему мы можем вызывать функции до их объявления

### Выполнение

В этой фазе переменным присваиваются значения, а функции вызываются и выполняются.

### Поднятие (hoisting)

это термин, описывающий подъем переменной или функции в глобальную или функциональную области видимости.

## **Event Propagation**

Когда какое-либо событие происходит в элементе DOM, оно на самом деле происходит не только в нем. Событие «распространяется» от объекта window до вызвавшего его элемента (event.target). При этом событие последовательно пронизывает всех предков целевого элемента. 

### Стадии

1. Фаза погружения — событие возникает в объекте window и опускается до цели события через всех ее предков.
2. Целевая фаза — это когда событие достигает целевого элемента.
3. Фаза всплытия — событие поднимается от event.target, последовательно проходит через всех его предков и достигает объекта window.

Метод `event.preventDefault()` **отключает поведение элемента по умолчанию**. Если использовать этот метод в элементе form, то он предотвратит отправку формы (submit). Если использовать его в contextmenu, то контекстное меню будет отключено (данный метод часто используется в keydown для переопределения клавиатуры, например, при создании музыкального/видео плеера или текстового редактора — прим. пер.). 

Метод `event.stopPropagation()` **отключает распространение события (его всплытие или погружение).**

## Функции теория

### Чистая функция

не имеет побочных эффектов и каждый раз возвращает одинаковый результат, когда она вызывается с тем же набором аргументов.

### Мемоизация

используется для кэширования результатов данной функции, чтобы предотвратить многократный вызов дорогостоящих в вычислительном отношении подпрограмм с одними и теми же аргументами.

- **Преимущество** мемоизации заключается в том, что мы избегаем повторного выполнения функции с одинаковыми аргументами.
- **Недостатком** является то, что мы вынуждены выделять дополнительную память для сохранения результатов.

```tsx
function memoize(func) {
  const cache = new Map();
  return function() {
    const key = JSON.stringify(arguments);
    if (cache.has(key)) {
        return cache.get(key);
    }
    const result = func.apply(this, arguments);
    cache.set(key, result);
    return result;
  };
}
```

### Каррирование

это трансформация функций таким образом, чтобы они принимали аргументы не как f(a, b, c), а как f(a)(b)(c).

```tsx
*function curry(f) { // curry(f) выполняет каррирование
  return function(a) {
    return function(b) {
      return f(a, b);
    };
  };
}
// использование
function sum(a, b) {
  return a + b;
}

let curriedSum = curry(sum);

alert( curriedSum(1)(2) ); // 3*
```

[Продвинутая реализация каррирования](https://learn.javascript.ru/currying-partials#prodvinutaya-realizatsiya-karrirovaniya)

В случае, если вам интересны детали, вот «продвинутая» реализация каррирования для функций с множеством аргументов, которую мы могли бы использовать выше.

```tsx
function curry(func) {
  return function curried(...args) {
    if (args.length >= func.length) {
      return func.apply(this, args);
    } else {
      return function(...args2) {
        return curried.apply(this, args.concat(args2));
      }
    }
  };
}
```

Примеры использования:

```tsx
function sum(a, b, c) {
  return a + b + c;
}

let curriedSum = curry(sum);

alert( curriedSum(1, 2, 3) ); // 6, всё ещё можно вызывать нормально
alert( curriedSum(1)(2,3) ); // 6, каррирование первого аргумента
alert( curriedSum(1)(2)(3) ); // 6, каррирование всех аргументов
```

### [Debounce](https://doka.guide/js/debounce/)

`debounce()`**— это функция, которая «откладывает» вызов другой функции до того момента, когда с последнего вызова пройдёт определённое количество времени.**

это метод предотвращения повторной активации функции в результате быстрой серии событий

Распространенными сценариями для `debounce` функции являются события `resize`, `scroll` и `keyup/keydown`. Кроме того, мы должны рассмотреть возможность использовать `debounce` при любом взаимодействии, которое вызывает чрезмерные вычисления или вызовы `API`.

```tsx
function debounce(func, delay) {
  let timeout;
  return function() {
    const context = this;
    const args = arguments;
    clearTimeout(timeout);
    timeout = setTimeout(() => func.apply(context, args), delay);
  };
}
```

### **[Throttle](https://doka.guide/js/throttle/)**

Просто запускать сложные и дорогостоящие операции на события `scroll` и `resize` — расточительно, потому что это может сильно нагрузить браузер и плохо сказаться на производительности.

Вместо этого можно обрабатывать изменения «раз в какое-то количество времени», используя `throttle`.

`throttle()`**— это функция, которая вызывает другую функцию, «пропуская» некоторые вызовы с определённой периодичностью.**

## **«use strict»**

это директива ES5, которая заставляет весь наш код или код отдельной функции выполняться в строгом режиме. Строгий режим вводит некоторые ограничения по написанию кода, тем самым позволяя избегать ошибок на ранних этапах.

Ограничения

1. Нельзя присваивать значения или обращаться к необъявленным переменным
2. Запрещено присваивать значения глобальный переменным, доступным только для чтения или записи
3. Нельзя удалить «неудаляемое» свойство объекта
4. Запрещено дублирование параметров функции
5. Нельзя создавать функции с помощью функции eval
6. Значением «this» по умолчанию является undefined